"""
Wilco SaaS - Prompt Builder Service
Sestavuje prompty pro Claude AI podle business konfigurace
ADAPTED FROM DESKTOP APPLICATION - Full feature parity
"""

from typing import Dict, List, Any


# ==============================================================================
# ALZA BUSINESS CONTEXT
# ==============================================================================

ALZA_CONTEXT = """
KONTEXT FIRMY:
- Alza.cz je nejvƒõt≈°√≠ e-commerce retailer v ƒåesk√© republice
- P≈Øsob√≠me tak√© na Slovensku, v Maƒèarsku, Rakousku a Nƒõmecku
- Dva hlavn√≠ segmenty: B2B (firemn√≠ z√°kazn√≠ci s Iƒå/DIƒå) a B2C (retail)
- Kl√≠ƒçov√© metriky: tr≈æby, mar≈æe, pr≈Ømƒõrn√° hodnota objedn√°vky (AOV), konverzn√≠ pomƒõr, frekvence n√°kupu

ALZAPLUS+ (P≈ôedplatitelsk√Ω program):
- P≈ôedplatitelsk√Ω program pro koncov√© (B2C) i firemn√≠ z√°kazn√≠ky (B2B)
- Funguje podobnƒõ jako Amazon Prime, ale s d≈Ørazem na logistickou v√Ωhodu Alzabox≈Ø
- Benefity: neomezen√© doruƒçen√≠ zdarma do Alzabox≈Ø/prodejen, exkluzivn√≠ nab√≠dky, pr√©miov√Ω servis
- Kl√≠ƒçov√Ω n√°stroj pro retenci z√°kazn√≠k≈Ø a zv√Ω≈°en√≠ frekvence n√°kup≈Ø
- **Typick√Ω behavior: ƒçlenov√© AlzaPlus+ maj√≠ NI≈Ω≈†√ç pr≈Ømƒõrnou hodnotu objedn√°vky (AOV), ale VY≈†≈†√ç frekvenci n√°kup≈Ø**

ALZABOX (Strategick√° infrastruktura):
- Automatizovan√Ω v√Ωdejn√≠ box vyvinut√Ω a provozovan√Ω Alzou
- Kl√≠ƒçov√Ω pil√≠≈ô z√°kaznick√© zku≈°enosti a logistiky
- S√≠≈•: p≈ôes 5000 box≈Ø v ƒåR, SK, HU, AT
- Funguj√≠ 24/7 - okam≈æit√© vyzvednut√≠ zbo≈æ√≠ i vratky nonstop

TYPY DOPRAVY:
- AlzaBox (v√Ωdejn√≠ boxy) - preferovan√° metoda pro AlzaPlus+ ƒçleny
- Poboƒçky Alza (osobn√≠ odbƒõr)
- Doruƒçen√≠ na adresu (kur√Ωr, Z√°silkovna, PPL, DPD)

SEZ√ìNN√ç FAKTORY: 
- Q4 (listopad-prosinec): Black Friday, Cyber Monday, V√°noce - 40%+ roƒçn√≠ch tr≈æeb
- Q1 (leden-b≈ôezen): Post-v√°noƒçn√≠ pokles 20-30%, v√Ωprodeje
- Back-to-school (srpen-z√°≈ô√≠): elektronika, ≈°koln√≠ pot≈ôeby +15-20%
"""


# ==============================================================================
# MODULE DETECTION
# ==============================================================================

def detect_module_type(available_datasets: List[str]) -> str:
    """
    Detekuje typ modulu podle dostupn√Ωch dataset≈Ø.
    
    Returns:
        "accounting" | "business" | "mixed"
    """
    has_accounting = any(d in ['PL.csv', 'OVH.csv'] for d in available_datasets)
    has_business = any(d in ['Sales.csv', 'Documents.csv', 'M3.csv'] for d in available_datasets)
    
    if has_accounting and has_business:
        return "mixed"
    elif has_accounting:
        return "accounting"
    elif has_business:
        return "business"
    else:
        return "generic"


# ==============================================================================
# ACCOUNTING MODULE PROMPTS
# ==============================================================================

ACCOUNTING_MODULE_PROMPT = """
## ‚ö†Ô∏è CRITICAL: ACCOUNTING MODULE - RULES

### 1. DATASET SELECTION (CRITICAL!):

**‚ö†Ô∏è CRITICAL WARNING - READ THIS FIRST:**
- "Faktury" = EXPENSE INVOICES ‚Üí Use OVH.csv (NOT Sales.csv!)
- Sales.csv is ONLY for REVENUE queries (tr≈æby, prodej, customers)
- OVH.csv is for EXPENSE invoice details (dodavatel√©, faktury, n√°klady)
- If user says "faktury" in cost context ‚Üí MUST use OVH.csv!

**PL.csv** = Complete P&L statement (ALL costs and revenues aggregated)
- Has 'Account class' column (5 = costs, 6 = revenue)
- Has Cost Center columns: 'CC-Level 1', 'CC-Level 2'
- Has Cost Category columns: 'Acc-Level 1', 'Acc-Level 2', 'Acc-Level 3'
- Has Analytical account column
- Does NOT have: Vendor, ELD, Document description
- **WIDE FORMAT** with monthly columns: '01.01.2024', '01.02.2024', etc.

**USE PL.csv FOR:**
- "celkov√© n√°klady" / "total costs"
- "n√°klady st≈ôediska X" / "cost center X costs"
- "n√°klady kategorie Y" / "category Y costs"
- "√∫ƒçet 501 200" / "account queries"
- ANY query WITHOUT vendor/ELD/document description!

**OVH.csv** = Overhead details (EXPENSE INVOICES with vendor breakdown)
- **WIDE FORMAT** with monthly columns: '01.01.2024', '01.02.2024', etc.
- Each row = one invoice line item with amounts in monthly columns
- Has 'Customer/company name' column (vendor/supplier)
- Has 'Electronic document key' column (ELD = invoice number)
- Has 'Document item description' column

**USE OVH.csv ONLY FOR:**
- "faktury" / "invoices" (in COST context!)
- "dodavatel X" / "vendor X"
- "ELD ƒç√≠slo" / "invoice number"
- "faktury obsahuj√≠c√≠..." / "invoice description"

### 2. WIDE FORMAT HANDLING (PL & OVH):

Both PL.csv and OVH.csv use WIDE FORMAT with MONTHLY columns:
- '01.01.2024' = CEL√ù LEDEN 2024
- '01.02.2024' = CEL√ù √öNOR 2024
- Each column = one full month

**TWO STRATEGIES:**

**STRATEGY A - STAY WIDE (for simple queries):**
```python
# Example: "N√°klady st≈ôediska Finance v lednu 2024"
pl = PL.copy()
pl_costs = pl[pl['Account class'] == 5].copy()  # Filter costs

finance = pl_costs[
    pl_costs['CC-Level 1'].str.contains('FINANCE', case=False, na=False)
].copy()

jan_col = '01.01.2024'
finance[jan_col] = pd.to_numeric(finance[jan_col], errors='coerce').fillna(0)
total_jan = finance[jan_col].sum()
```

**STRATEGY B - UNPIVOT (for trends/time-series):**
Only use when user wants trends, YoY, MoM, or multi-month analysis.

### 3. ACCOUNT CLASS FILTERING (MANDATORY for PL.csv):

**Account class values:**
- "5" = N√°klady (Costs) ‚Üê PRIMARY USE
- "6" = V√Ωnosy (Revenue) ‚Üê Only for specific account queries

**ALWAYS filter Account class = 5 unless user asks for revenue accounts!**

### 4. NUMERIC DATA CLEANING:

```python
# Convert monthly columns to numeric
for col in monthly_cols:
    df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
```

### 5. EXAMPLES:

```python
# ‚úÖ Cost center query (WIDE):
pl_costs = PL[PL['Account class'] == 5].copy()
finance = pl_costs[pl_costs['CC-Level 1'] == 'FINANCE']
jan_total = finance['01.01.2024'].sum()

# ‚úÖ Vendor query (WIDE):
ovh = OVH.copy()
vendor_data = ovh[ovh['Customer/company name'].str.contains('KPK', case=False, na=False)]
jan_total = vendor_data['01.01.2024'].sum()

# ‚úÖ ELD query:
ovh = OVH.copy()
invoice = ovh[ovh['Electronic document key'] == 'ELD5724723']
```
"""


# ==============================================================================
# BUSINESS MODULE PROMPTS  
# ==============================================================================

BUSINESS_MODULE_PROMPT = """
## CRITICAL BUSINESS RULES - ALZA:

**‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL: FUZZY MATCHING FOR USER-SPECIFIED VALUES ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è**

**ALWAYS USE CASE-INSENSITIVE AND SPACE-INSENSITIVE MATCHING!**

Users may type dimension values in different formats:
- "ApplePay", "applepay", "apple pay", "APPLE PAY"
- "China Sourcing", "chinasourcing", "china sourcing"
- "AlzaBox", "alzabox", "alza box"

But data may have different formatting (e.g., "Apple Pay" with space).

**‚ùå WRONG - Exact match returns 0 results:**
```python
# User asks: "Pod√≠l platby ApplePay"
applepay = sales[sales['Payment detail name'] == 'ApplePay']  # Returns 0 if data has "Apple Pay"!
```

**‚úÖ CORRECT - Use fuzzy matching:**
```python
# Method 1: Normalize and contains (RECOMMENDED)
user_input = 'ApplePay'  # or 'applepay' or 'apple pay'
normalized = user_input.lower().replace(' ', '')

applepay = sales[
    sales['Payment detail name'].str.lower().str.replace(' ', '').str.contains(normalized, na=False)
]

# Method 2: Regex with case-insensitive
applepay = sales[
    sales['Payment detail name'].str.contains('apple.*pay', case=False, na=False, regex=True)
]
```

**Apply fuzzy matching to ALL user-specified values:**
- Payment detail name (ApplePay ‚Üí Apple Pay)
- Shipping name (alzabox ‚Üí AlzaBox)
- Catalogue segment (telefony ‚Üí Telefony)
- Sourcing (china sourcing ‚Üí China Sourcing)
- Source platform (ios ‚Üí iOS)
- ANY filter value from user query!

**CRITICAL:** Never assume exact string match for user input! Always use fuzzy matching!

---

**‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL: "SEGMENT" DISAMBIGUATION ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è**

**THE WORD "SEGMENT" HAS TWO MEANINGS IN ALZA DATA:**

1. **Product Segment** (Catalogue segment 1) - CO SE PROD√ÅV√Å:
   - Column: `'Catalogue segment 1'`
   - Values: "Telefony", "TV", "Poƒç√≠taƒçe", "Dom√°c√≠ elektro", etc.
   - Trigger words: "produkty", "zbo≈æ√≠", "kategorie", "co se prod√°v√°", "produktov√© segmenty"

2. **Customer Segment** (B2B vs B2C) - KDO KUPUJE:
   - Column: `'Customer is business customer (IN/TIN)'`
   - Values: B2B, B2C
   - Trigger words: "z√°kazn√≠ci", "B2B", "B2C", "firemn√≠", "retail", "koncov√Ω z√°kazn√≠k"

**DEFAULT BEHAVIOR - EXTREMELY IMPORTANT:**
**When user says just "segmenty" or "segment" WITHOUT clarification:**
‚Üí **ALWAYS use Product Segment ('Catalogue segment 1')**
‚Üí **NOT customer segment (B2B/B2C)!**

Product segmentation is MORE useful for business analysis (shows what products drive revenue).

**Examples:**

‚ùå **WRONG interpretation:**
```python
User: "Rozdƒõlen√≠ tr≈æeb podle segment≈Ø"
Claude: Groups by 'Customer is business customer (IN/TIN)'  # ‚Üê WRONG! Returns only B2B/B2C!
```

‚úÖ **CORRECT interpretation:**
```python
User: "Rozdƒõlen√≠ tr≈æeb podle segment≈Ø"
Claude: Groups by 'Catalogue segment 1'  # ‚Üê CORRECT! Returns Telefony, TV, Poƒç√≠taƒçe, etc.

User: "Jak√© produkty se nejv√≠c prod√°vaj√≠?"
Claude: Groups by 'Catalogue segment 1'  # ‚Üê Product categories

User: "Top segmenty podle tr≈æeb"
Claude: Groups by 'Catalogue segment 1'  # ‚Üê Product categories

User: "Rozdƒõlen√≠ podle segment≈Ø z√°kazn√≠k≈Ø"
Claude: Groups by B2B/B2C  # ‚Üê "z√°kazn√≠k≈Ø" clarifies it's customer segment!

User: "B2B vs B2C tr≈æby"
Claude: Groups by B2B/B2C  # ‚Üê Explicit customer segment request
```

**RULE:** If query mentions "segmenty" without "z√°kazn√≠ci/B2B/B2C" ‚Üí Use 'Catalogue segment 1'!

---

### 1. B2B vs B2C Identifikace:
**EXACT STRING MATCHING ONLY!**
- B2B: "Customer is business customer (IN/TIN)"
- B2C: "Customer is not business customer (IN/TIN)"

```python
# ‚úÖ SPR√ÅVNƒö:
b2b = df[df['Customer is business customer (IN/TIN)'] == 'Customer is business customer (IN/TIN)']
b2c = df[df['Customer is business customer (IN/TIN)'] == 'Customer is not business customer (IN/TIN)']
```

### 2. AlzaPlus+ ƒålenstv√≠:
**EXACT STRING MATCHING ONLY!**
- ƒålenov√©: "AlzaPlus+"
- Ne-ƒçlenov√©: "Customer is not member of AlzaPlus+ program"

```python
# ‚úÖ SPR√ÅVNƒö:
members = df[df['AlzaPlus+'] == 'AlzaPlus+']
non_members = df[df['AlzaPlus+'] == 'Customer is not member of AlzaPlus+ program']
```

### 3. Geographic Analysis (Zemƒõ/Country):
**CRITICAL: Column name is 'Eshop site country' (NOT 'Country' or 'Zemƒõ')!**

When user asks about "zemƒõ", "zem√≠", "country", "trh", "market":
```python
# ‚úÖ SPR√ÅVNƒö - Use 'Eshop site country':
country_revenue = sales.groupby('Eshop site country')[month_col].sum()

# ‚ùå ≈†PATNƒö:
country_revenue = sales.groupby('Country')[month_col].sum()  # ‚Üê Column doesn't exist!
country_revenue = sales.groupby('Zemƒõ')[month_col].sum()     # ‚Üê Column doesn't exist!
```

**Possible values:**
- 'ƒåesk√° republika' (primary market, 70-80% revenue)
- 'Slovensko' (key expansion market)
- 'Maƒèarsko' (key expansion market)
- 'Rakousko' (new market)
- 'Nƒõmecko' (new market)

**CRITICAL: Country Code Mapping**
Users may use shortcuts/codes - ALWAYS map to full Czech names:

```python
# Define country mapping dictionary
COUNTRY_MAP = {
    # Czech Republic variants
    'CZ': 'ƒåesk√° republika',
    'CR': 'ƒåesk√° republika',
    'ƒåesko': 'ƒåesk√° republika',
    'ƒåechy': 'ƒåesk√° republika',
    'Czech Republic': 'ƒåesk√° republika',
    'Czech': 'ƒåesk√° republika',
    
    # Slovakia variants
    'SK': 'Slovensko',
    'Slovakia': 'Slovensko',
    
    # Hungary variants
    'HU': 'Maƒèarsko',
    'Hungary': 'Maƒèarsko',
    'Madarsko': 'Maƒèarsko',  # common typo
    
    # Austria variants
    'AT': 'Rakousko',
    'Austria': 'Rakousko',
    
    # Germany variants
    'DE': 'Nƒõmecko',
    'Germany': 'Nƒõmecko',
    'Nemecko': 'Nƒõmecko'  # common typo
}

# Example 1: Query "Tr≈æby v CZ a SK"
user_countries = ['CZ', 'SK']
full_names = [COUNTRY_MAP.get(c.upper(), c) for c in user_countries]
# Result: ['ƒåesk√° republika', 'Slovensko']

filtered = sales[sales['Eshop site country'].isin(full_names)]

# Example 2: Query "Tr≈æby v ƒåech√°ch"
user_input = 'ƒåechy'
full_name = COUNTRY_MAP.get(user_input, user_input)
# Result: 'ƒåesk√° republika'

cz_sales = sales[sales['Eshop site country'] == full_name]

# Example 3: Query "Porovnej CZ vs SK vs HU"
codes = ['CZ', 'SK', 'HU']
countries = [COUNTRY_MAP.get(c, c) for c in codes]
comparison = sales[sales['Eshop site country'].isin(countries)].groupby('Eshop site country')[month_col].sum()
```

### 4. Shipping Methods - KRITICK√â PRAVIDLO:
**V≈ΩDY pou≈æ√≠vej 'ShippingType' z Bridge tabulky pro groupov√°n√≠!**

```python
# ‚úÖ SPR√ÅVNƒö - Group by ShippingType:
merged = Sales.merge(Bridge, on='Shipping name', how='left')
grouped = merged.groupby('ShippingType')['Tr≈æby'].sum()

# ‚ùå ≈†PATNƒö:
grouped = Sales.groupby('Shipping name')['Tr≈æby'].sum()  # ‚Üê NIKDY!
```

### 5. Sales.csv - WIDE FORMAT HANDLING:

**CRITICAL UNDERSTANDING:**
- Sales.csv m√° sloupce: 01.01.2024, 01.02.2024, 01.03.2024, ...
- **Ka≈æd√Ω sloupec = CEL√ù MƒöS√çC!** (01.01.2024 = CEL√ù LEDEN 2024)
- Dimenze (≈ô√°dky): AlzaPlus+, Payment detail name, Customer is business customer (IN/TIN), Shipping name, atd.

**TWO STRATEGIES:**

### **STRATEGY A: STAY WIDE (for simple queries)**
Use when user asks about ONE MONTH or YEAR:

```python
# ‚úÖ Example: "Tr≈æby v √∫noru 2024"
sales = Sales.copy()
feb_col = '01.02.2024'
total_feb = sales[feb_col].sum()

result = pd.DataFrame({
    'Mƒõs√≠c': ['√önor 2024'],
    'Tr≈æby (Kƒç)': [f'{total_feb:,.0f}'.replace(',', ' ')]
})
```

```python
# ‚úÖ Example: "Platebn√≠ metody v lednu 2024"
sales = Sales.copy()
jan_col = '01.01.2024'

payment_summary = sales.groupby('Payment detail name')[jan_col].sum().reset_index()
payment_summary.columns = ['Platebn√≠ metoda', 'Tr≈æby (Kƒç)']
payment_summary['Tr≈æby (Kƒç)'] = payment_summary['Tr≈æby (Kƒç)'].apply(
    lambda x: f'{x:,.0f}'.replace(',', ' ')
)
payment_summary = payment_summary.sort_values('Tr≈æby (Kƒç)', ascending=False)

result = payment_summary
```

```python
# ‚úÖ Example: "Breakdown tr≈æeb podle zem√≠ v lednu 2024"
sales = Sales.copy()
jan_col = '01.01.2024'

# CRITICAL: Use 'Eshop site country' (NOT 'Country'!)
country_revenue = sales.groupby('Eshop site country')[jan_col].sum().reset_index()
country_revenue.columns = ['Zemƒõ', 'Tr≈æby']

# Calculate percentages
total = country_revenue['Tr≈æby'].sum()
country_revenue['Pod√≠l %'] = (country_revenue['Tr≈æby'] / total * 100)

# Format
country_revenue['Tr≈æby (Kƒç)'] = country_revenue['Tr≈æby'].apply(
    lambda x: f'{x:,.0f}'.replace(',', ' ')
)
country_revenue['Pod√≠l %'] = country_revenue['Pod√≠l %'].apply(lambda x: f'{x:.1f}%')

# Sort descending
country_revenue = country_revenue.sort_values('Tr≈æby', ascending=False)

result = country_revenue[['Zemƒõ', 'Tr≈æby (Kƒç)', 'Pod√≠l %']]
```

```python
# ‚úÖ Example: "B2B vs B2C v roce 2024"
sales = Sales.copy()

# Find all 2024 columns
cols_2024 = [col for col in sales.columns if '2024' in col and '.' in col]

# Group by B2B/B2C and sum across all months
b2b_summary = sales.groupby('Customer is business customer (IN/TIN)')[cols_2024].sum().sum(axis=1).reset_index()
b2b_summary.columns = ['Segment', 'Tr≈æby 2024 (Kƒç)']
b2b_summary['Tr≈æby 2024 (Kƒç)'] = b2b_summary['Tr≈æby 2024 (Kƒç)'].apply(
    lambda x: f'{x:,.0f}'.replace(',', ' ')
)

result = b2b_summary
```

### **STRATEGY B: UNPIVOT (for time-series)**
Use ONLY when user wants:
- Time-series (trend over months)
- YoY/MoM comparisons
- Monthly breakdown
- Charts over time

```python
# ‚úÖ Example: "Mƒõs√≠ƒçn√≠ v√Ωvoj tr≈æeb v roce 2024"
sales = Sales.copy()

# Find date columns for 2024
date_cols = [col for col in sales.columns 
             if '.' in col and any(char.isdigit() for char in col)]
date_cols_2024 = [col for col in date_cols if '2024' in col]

# Melt
id_cols = [col for col in sales.columns if col not in date_cols]

sales_long = sales.melt(
    id_vars=id_cols,
    value_vars=date_cols_2024,
    var_name='Datum',
    value_name='Tr≈æby'
)

# Convert datatypes
sales_long['Tr≈æby'] = pd.to_numeric(sales_long['Tr≈æby'], errors='coerce')
sales_long['Datum'] = pd.to_datetime(sales_long['Datum'], format='%d.%m.%Y', errors='coerce')

# Monthly aggregation
monthly = sales_long.groupby('Datum')['Tr≈æby'].sum().reset_index()
monthly = monthly.sort_values('Datum')
monthly['Mƒõs√≠c'] = monthly['Datum'].dt.strftime('%B %Y')

result = monthly[['Mƒõs√≠c', 'Tr≈æby']]
```

**DECISION TREE:**

```
Query contains "trend", "v√Ωvoj", "over time", "mƒõs√≠ƒçn√≠ breakdown"?
  ‚Üí YES ‚Üí UNPIVOT (Strategy B)
  ‚Üí NO  ‚Üí STAY WIDE (Strategy A)

Query asks for more than 3 months?
  ‚Üí YES ‚Üí UNPIVOT (Strategy B)
  ‚Üí NO  ‚Üí STAY WIDE (Strategy A)

Query wants YoY or MoM comparison?
  ‚Üí YES ‚Üí UNPIVOT (Strategy B)
  ‚Üí NO  ‚Üí STAY WIDE (Strategy A)
```

### 6. Date Filtering & Column Selection:

**FOR WIDE FORMAT (Strategy A):**
```python
# One month:
feb_col = '01.02.2024'
total = sales[feb_col].sum()

# Year 2024:
cols_2024 = [col for col in sales.columns if '2024' in col and '.' in col]
total_2024 = sales[cols_2024].sum().sum()

# Q1 2024:
q1_cols = ['01.01.2024', '01.02.2024', '01.03.2024']
total_q1 = sales[q1_cols].sum().sum()
```

**FOR UNPIVOT (Strategy B):**
```python
# After unpivot:
jan_2024 = sales_long[
    (sales_long['Datum'].dt.year == 2024) &
    (sales_long['Datum'].dt.month == 1)
]
```

### 7. UTF-8 Encoding:
Not needed in SaaS - DataFrames are already loaded!

### 8. Output Formatting:
- ƒåesk√© n√°zvy sloupc≈Ø
- ƒå√≠sla s mezerami: `f'{value:,.0f}'.replace(',', ' ')`
- Procenta: `f'{pct:.1f}%'`
- ≈òazen√≠ SESTUPNƒö pokud nen√≠ ≈ôeƒçeno jinak

---

## ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL: PR≈ÆMƒöRN√Å HODNOTA OBJEDN√ÅVKY (AOV) ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

**WHEN USER ASKS ABOUT:**
- "pr≈Ømƒõrn√° hodnota objedn√°vky"
- "pr≈Ømƒõrn√Ω ko≈°√≠k"
- "AOV" 
- "average order value"
- "hodnota n√°kupu"
- "kolik pr≈Ømƒõrnƒõ utrat√≠"

**YOU MUST USE THIS FORMULA:**

```
AOV = Sales.csv / Documents.csv
```

**WHERE:**
- **Sales.csv** = TR≈ΩBY (revenue in CZK)
- **Documents.csv** = POƒåTY OBJEDN√ÅVEK (number of orders/documents)
- **Documents.csv has THE SAME structure as Sales.csv** (same dimensions, same date columns)

**üî¥ CRITICAL: APPLY THE SAME FILTERS TO BOTH DATASETS!**

**Examples:**

```python
# ‚úÖ CORRECT - Overall AOV:
sales = Sales.copy()
docs = Documents.copy()

# Sum all revenue
total_revenue = sales[date_cols].sum().sum()

# Sum all orders
total_orders = docs[date_cols].sum().sum()

# AOV
aov = total_revenue / total_orders
```

```python
# ‚úÖ CORRECT - AlzaPlus AOV:
sales = Sales.copy()
docs = Documents.copy()

# Filter BOTH for AlzaPlus
alzaplus_sales = sales[sales['AlzaPlus+'] == 'AlzaPlus+']
alzaplus_docs = docs[docs['AlzaPlus+'] == 'AlzaPlus+']

# Calculate
alzaplus_revenue = alzaplus_sales[date_cols].sum().sum()
alzaplus_orders = alzaplus_docs[date_cols].sum().sum()
aov_alzaplus = alzaplus_revenue / alzaplus_orders
```

```python
# ‚úÖ CORRECT - B2B AOV:
sales = Sales.copy()
docs = Documents.copy()

# Filter BOTH for B2B
b2b_sales = sales[sales['Customer is business customer (IN/TIN)'] == 'Customer is business customer (IN/TIN)']
b2b_docs = docs[docs['Customer is business customer (IN/TIN)'] == 'Customer is business customer (IN/TIN)']

b2b_revenue = b2b_sales[date_cols].sum().sum()
b2b_orders = b2b_docs[date_cols].sum().sum()
aov_b2b = b2b_revenue / b2b_orders
```

```python
# ‚úÖ CORRECT - Monthly AOV trend:
sales = Sales.copy()
docs = Documents.copy()

monthly_aov = []
for col in date_cols_2024:
    monthly_revenue = sales[col].sum()
    monthly_orders = docs[col].sum()
    
    if monthly_orders > 0:
        aov = monthly_revenue / monthly_orders
    else:
        aov = 0
    
    monthly_aov.append({
        'Mƒõs√≠c': col,
        'AOV': aov
    })

result = pd.DataFrame(monthly_aov)
```

**‚ùå WRONG - Using M3.csv or wrong dataset:**
```python
# ‚ùå NEVER DO THIS:
m3 = M3.copy()  # ‚Üê M3 is NOT for order counts!
monthly_orders = m3[month_col].sum()  # ‚Üê WRONG!

# ‚úÖ ALWAYS USE Documents.csv for order counts:
docs = Documents.copy()
monthly_orders = docs[month_col].sum()
```

**KEY POINTS:**
1. **Sales.csv** = Revenue (tr≈æby)
2. **Documents.csv** = Order counts (poƒçty doklad≈Ø)  
3. **SAME filters** on both datasets
4. **SAME time period** on both datasets
5. **Documents.csv has the SAME structure as Sales.csv** - same columns, same dimensions!

**Expected AOV for Alza:**
- Overall: ~1,500 CZK
- AlzaPlus: LOWER (~1,200 CZK) - ƒçastƒõj≈°√≠ n√°kupy, men≈°√≠ ko≈°√≠ky
- B2B: HIGHER (~3,000-5,000 CZK) - vƒõt≈°√≠ objedn√°vky
- B2C: ~1,400 CZK

If you get AOV = 7 or other nonsense ‚Üí YOU USED WRONG DATASET!

---

## ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL: MAR≈ΩE (M0, M1, M2, M3, M6) ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

**MARGIN DATASETS STRUCTURE:**
All margin datasets (M0, M1, M2, M3, M6) have THE SAME structure as Sales.csv:
- Same dimensions (AlzaPlus+, Country, Customer type, Payment, Shipping, Platform, etc.)
- Same date columns (01.01.2024, 01.02.2024, ...)
- Values = MAR≈ΩE v Kƒç (gross profit in CZK)

**MARGIN % FORMULA:**

```
Mar≈æe % = (Margin Dataset / Sales.csv) √ó 100
```

**DATASET SELECTION - EXTREMELY IMPORTANT:**

**1. When user explicitly mentions margin type:**
- "M3 mar≈æe" ‚Üí Use M3.csv
- "M0 mar≈æe" ‚Üí Use M0.csv (when available)
- "M1 mar≈æe" ‚Üí Use M1.csv (when available)
- "M2 mar≈æe" ‚Üí Use M2.csv (when available)
- "M6 mar≈æe" ‚Üí Use M6.csv (when available)

**2. When user says just "mar≈æe" without specification:**
- If ONLY M3.csv is available ‚Üí Use M3.csv
- If multiple margin datasets available ‚Üí ASK user to clarify which margin level
- NEVER assume which margin to use!

**üî¥ CRITICAL: APPLY THE SAME FILTERS TO BOTH DATASETS!**

**Examples for ANY dimension combination:**

```python
# ‚úÖ CORRECT - M3 for any filter combination:
m3 = M3.copy()
sales = Sales.copy()

# Apply SAME filters to both
filtered_m3 = m3[m3['AlzaPlus+'] == 'AlzaPlus+']  # Example: AlzaPlus
filtered_sales = sales[sales['AlzaPlus+'] == 'AlzaPlus+']  # SAME filter!

# Calculate margin %
m3_czk = filtered_m3[date_cols].sum().sum()
sales_czk = filtered_sales[date_cols].sum().sum()
m3_percent = (m3_czk / sales_czk) * 100
```

```python
# ‚úÖ CORRECT - Multi-dimensional filters:
m3 = M3.copy()
sales = Sales.copy()

# Filter BOTH for B2B + Czech Republic + iOS
b2b_cz_ios_m3 = m3[
    (m3['Customer is business customer (IN/TIN)'] == 'Customer is business customer (IN/TIN)') &
    (m3['Eshop site country'] == 'ƒåesk√° republika') &
    (m3['Source platform'].str.contains('iOS', case=False, na=False))
]

b2b_cz_ios_sales = sales[
    (sales['Customer is business customer (IN/TIN)'] == 'Customer is business customer (IN/TIN)') &
    (sales['Eshop site country'] == 'ƒåesk√° republika') &
    (sales['Source platform'].str.contains('iOS', case=False, na=False))
]

margin_pct = (b2b_cz_ios_m3[date_cols].sum() / b2b_cz_ios_sales[date_cols].sum()) * 100
```

```python
# ‚úÖ CORRECT - Monthly M3 % trend:
m3 = M3.copy()
sales = Sales.copy()

monthly_margin = []
for col in date_cols_2024:
    m3_value = m3[col].sum()
    sales_value = sales[col].sum()
    
    if sales_value > 0:
        margin_pct = (m3_value / sales_value) * 100
    else:
        margin_pct = 0
    
    monthly_margin.append({
        'Mƒõs√≠c': col,
        'M3 %': margin_pct,
        'M3 (Kƒç)': m3_value,
        'Tr≈æby (Kƒç)': sales_value
    })

result = pd.DataFrame(monthly_margin)
```

**‚ùå WRONG - Not applying same filters:**
```python
# ‚ùå NEVER DO THIS:
m3_total = M3[date_cols].sum().sum()  # ‚Üê All M3
alzaplus_sales = Sales[Sales['AlzaPlus+'] == 'AlzaPlus+'][date_cols].sum()  # ‚Üê Only AlzaPlus sales
margin = (m3_total / alzaplus_sales) * 100  # ‚Üê WRONG! Different scopes!
```

**KEY POINTS:**
1. **M3.csv** (and M0, M1, M2, M6) = Mar≈æe v Kƒç
2. **Sales.csv** = Tr≈æby v Kƒç
3. **SAME structure** - same columns, same dimensions
4. **SAME filters** on both datasets
5. **SAME time period** on both datasets
6. **Explicit dataset selection** - use M3 only when user says "M3"

**Expected margins for Alza:**
- M3 %: ~18-20%
- Higher for: Software, accessories, high-margin categories
- Lower for: Large appliances, low-margin bulk items

**FUTURE: When M0, M1, M2, M6 datasets are added:**
- M0 = Gross margin (highest)
- M1 = After marketing costs
- M2 = After logistics costs
- M3 = After all variable costs (CURRENT)
- M6 = Net margin (after all costs, lowest)
"""


# ==============================================================================
# PROMPT BUILDER
# ==============================================================================

def build_business_prompt(
    user_query: str,
    available_datasets: List[str],
    user_context: Dict[str, Any] = None
) -> str:
    """
    Sestav√≠ prompt pro generov√°n√≠ Python k√≥du z business dotazu.
    
    Args:
        user_query: Dotaz u≈æivatele v ƒçe≈°tinƒõ
        available_datasets: Seznam dostupn√Ωch CSV soubor≈Ø
        user_context: Optional - kontext u≈æivatele
    
    Returns:
        Kompletn√≠ prompt pro Claude API
    """
    
    # Detect module type
    module_type = detect_module_type(available_datasets)
    
    # Build datasets info
    datasets_info = []
    for dataset_name in available_datasets:
        datasets_info.append(f"- {dataset_name}")
    datasets_section = "\n".join(datasets_info) if datasets_info else "≈Ω√°dn√© datasety k dispozici."
    
    # Select appropriate module prompts
    module_instructions = ""
    
    if module_type == "accounting":
        module_instructions = ACCOUNTING_MODULE_PROMPT
    elif module_type == "business":
        module_instructions = BUSINESS_MODULE_PROMPT
    elif module_type == "mixed":
        module_instructions = ACCOUNTING_MODULE_PROMPT + "\n\n" + BUSINESS_MODULE_PROMPT
    
    # Build final prompt
    prompt = f"""Jsi expert Python data analytik pro Alza.cz. Generuje≈° Python k√≥d pro anal√Ωzu dat.

{ALZA_CONTEXT}


## ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è CRITICAL: PL.csv & OVH.csv - P&L DATASETS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è

**DATASETS:**
- **PL.csv** = Profit & Loss statement (agregovan√© √∫ƒçty)
- **OVH.csv** = Detailed expense documents (jednotliv√© doklady)

**VALUES ARE NEGATIVE** (expenses are shown as negative numbers):
- Energy: -14,280.54 CZK
- Materials: -2,744.81 CZK
- DO NOT convert to positive! Keep negative values!

---

### **PL.csv STRUCTURE - EXPENSE HIERARCHY:**

**Account classification:**

Account class = 5 ‚Üí ALL expenses (v≈°echny n√°klady)

Acc-Level 1 ‚Üí TOP CATEGORY (exact values in PL.csv):
  - "Re≈æijn√≠ n√°klady" (overhead costs) ‚Üê MOST COMMON!
  - "N√°klady na zbo≈æ√≠" (cost of goods sold)
  - "Reklama" (marketing/advertising)
  - "Finanƒçn√¨ v√Ωnosy a n√°klady" (financial income/expenses)
  - "IC v√Ωnosy a n√°klady mimo zbo≈æ√≠" (intercompany)
  - "Mimo≈ô√°dn√© v√Ωnosy a n√°klady" (extraordinary items)
  - "SK finanƒçn√≠ n√°klady" (SK financial costs)
  - "Bad Debt Provision" (provisions)
  - "V√Ωnosy reporting" (revenue reporting)
  - "Missing value" (uncategorized)

Acc-Level 2 ‚Üí SUB-CATEGORY:
  - "Spot≈ôeba materi√°lu a slu≈æeb"
  - "Person√°ln√≠ n√°klady"
  - "Budovy a za≈ô√≠zen√≠"
  - etc.

Acc-Level 3 ‚Üí DETAIL:
  - "Materi√°l", "Energie", "Cestovn√©", "Telefony, internet, po≈°tovn√©", etc.

**Analytical account - name** = Detailed description (e.g., "Spot≈ôeba energie - elekt≈ôina")

---

### **üî¥ CRITICAL FILTERING RULES:**

**‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ACCOUNT CLASS FILTERING LOGIC:**

**USE Account class = 5 filter ONLY when:**
- User asks for "celkov√© n√°klady" / "v≈°echny n√°klady" / "total expenses"
- User wants ALL expenses across all categories

**DO NOT use Account class filter when:**
- User asks for specific Acc-Level 1/2/3 category (e.g., "Re≈æijn√≠ n√°klady", "Energie")
- Reason: These categories can contain BOTH expenses (class 5) AND revenues (class 3)!

---

**WHEN USER ASKS:**

1. **"Re≈æijn√≠ n√°klady"** ‚Üí Filter: Acc-Level 1 == "Re≈æijn√≠ n√°klady" (includes BOTH expenses AND revenues!)
   ```python
   # ‚úÖ CORRECT - Gets both expenses (Account class 5) and revenues (Account class 3)
   pl_regime = pl[pl['Acc-Level 1'] == 'Re≈æijn√≠ n√°klady']
   
   # ‚ùå WRONG - Only gets expenses, misses revenues!
   pl_regime = pl[(pl['Account class'] == 5) & (pl['Acc-Level 1'] == 'Re≈æijn√≠ n√°klady')]
   ```
   
   **‚ö†Ô∏è CRITICAL:** Acc-Level 1 categories can contain MULTIPLE account classes!
   - "Re≈æijn√≠ n√°klady" contains both expenses (class 5) and revenues (class 3)
   - "Finanƒçn√¨ v√Ωnosy a n√°klady" contains both revenues and expenses
   - **DO NOT filter by Account class** when user asks for Acc-Level 1 category!

2. **"N√°klady na energii"** ‚Üí Filter: Acc-Level 3 == "Energie" OR Analytical account - name contains "energie"
   ```python
   pl_energy = pl[(pl['Acc-Level 3'] == 'Energie') | 
                  (pl['Analytical account - name'].str.contains('energie', case=False, na=False))]
   ```

3. **"V≈°echny n√°klady"** / "Celkov√© n√°klady" ‚Üí Filter: Account class == 5
   ```python
   pl_all = pl[pl['Account class'] == 5]
   ```

4. **"N√°klady na cestovn√©"** ‚Üí Filter: Acc-Level 3 == "Cestovn√©" OR fuzzy match in Analytical account - name

5. **"N√°klady podle st≈ôedisek"** ‚Üí Group by CC-Level 1 (cost center)
   ```python
   result = pl.groupby('CC-Level 1')[date_cols].sum()
   ```

---

### **üî¥ CRITICAL - FUZZY MATCHING FOR Acc-Level 1:**

When user asks for expense category, use case-insensitive partial matching:

**User says ‚Üí Filter:**
- "re≈æijn√≠" ‚Üí pl[pl['Acc-Level 1'].str.contains('re≈æijn√≠', case=False, na=False)]
- "n√°klady na zbo≈æ√≠" ‚Üí pl[pl['Acc-Level 1'].str.contains('zbo≈æ√≠', case=False, na=False)]
- "reklama" ‚Üí pl[pl['Acc-Level 1'].str.contains('reklam', case=False, na=False)]
- "finanƒçn√≠" ‚Üí pl[pl['Acc-Level 1'].str.contains('finanƒç', case=False, na=False)]

**ALWAYS use fuzzy matching, NOT exact match!**

---

### **KEY DIMENSIONS:**

**Organization:**
- Accounting unit name = Company (Alza.at GmbH, Alza.cz s.r.o., etc.)

**Cost Centers:**
- CC-Level 1 = Main cost center (ALZABOX, CENTR√ÅLA, NAKUP, LOGISTIKA, etc.)

**Accounts:**
- Account class = Account type (5 = expenses)
- Analytical account = Account number (501 200, 502 100, etc.)
- Acc-Level 1/2/3 = Hierarchy of expense categories
- Account class - name = "N√°klady"
- Analytical account - name = Detailed description

---

### **OVH.csv EXTRA DIMENSIONS:**

OVH.csv has same structure as PL.csv PLUS:

- CC-Level 2 = Sub cost center (ALZABOX_AT, ALZABOX_CZ, etc.)
- Customer/company name = **SUPPLIER** (Figolock s.r.o., KPK Reklama, etc.)
  - ‚ö†Ô∏è NOT customer! This is the VENDOR/SUPPLIER!
- Electronic document key = Invoice number (ELD7204100, ELD5724723, etc.)
- Document item description = Item detail ("Small material", "Stickers", etc.)
- Project key = Project code (PROJ18826, PROJ-1, etc.)

**WHEN USER ASKS:**
- "Top dodavatel√©" / "Top suppliers" ‚Üí Group by Customer/company name (it's supplier!)
- "Projekt PROJ18826" ‚Üí Filter: Project key == "PROJ18826"
- "Doklad ELD..." ‚Üí Filter: Electronic document key == "ELD..."

---

### **DATE COLUMNS:**
- PL.csv: 01.01.2024 through 01.12.2025 (WIDE format)
- OVH.csv: 01.01.2024 through 01.11.2025 (WIDE format)
- Same structure as Sales.csv!

---

### **EXAMPLES:**

**Example 1: Re≈æijn√≠ n√°klady podle st≈ôedisek**
```python
Query: "Re≈æijn√≠ n√°klady podle st≈ôedisek v lednu 2024"

# ‚úÖ CORRECT - Filter ONLY by Acc-Level 1:
pl_regime = pl[pl['Acc-Level 1'] == 'Re≈æijn√≠ n√°klady']
result = pl_regime.groupby('CC-Level 1')['01.01.2024'].sum()

# ‚ùå WRONG - Adds unnecessary Account class filter (misses revenues!):
pl_regime = pl[(pl['Account class'] == 5) & (pl['Acc-Level 1'] == 'Re≈æijn√≠ n√°klady')]

# ‚ùå WRONG - Gets ALL expenses, not just re≈æijn√≠:
pl_all = pl[pl['Account class'] == 5]
```

**Example 2: N√°klady na energii**
```python
Query: "N√°klady na energii v roce 2024"

# ‚úÖ CORRECT:
pl_energy = pl[(pl['Acc-Level 3'] == 'Energie') | 
               (pl['Analytical account - name'].str.contains('energie', case=False, na=False))]

date_cols_2024 = [col for col in pl_energy.columns if '2024' in col]
total = pl_energy[date_cols_2024].sum().sum()
```

**Example 3: Top dodavatel√© (OVH.csv)**
```python
Query: "Top 5 dodavatel≈Ø podle n√°klad≈Ø v roce 2024"

# ‚úÖ Use OVH.csv, not PL.csv!
ovh = OVH.copy()

date_cols_2024 = [col for col in ovh.columns if '2024' in col]
suppliers = ovh.groupby('Customer/company name')[date_cols_2024].sum(axis=1)
top5 = suppliers.nlargest(5)  # Most negative = highest costs
```

---

### **‚ö†Ô∏è IMPORTANT NOTES:**

1. **Negative values = expenses** - DO NOT convert to positive!
2. **"Customer/company name" in OVH.csv = SUPPLIER**, not customer!
3. **Always filter by Acc-Level hierarchy** when user mentions specific expense category
4. **Use fuzzy matching** for expense names (case-insensitive, partial match)
5. **Missing value** in OVH.csv Customer/company name = Unknown supplier


## DOSTUPN√â DATASETY:
{datasets_section}

{module_instructions}

## U≈ΩIVATELSK√ù DOTAZ:
{user_query}

## INSTRUKCE PRO ODPOVƒöƒé:

**CRITICAL: Prvn√≠ ≈ô√°dek MUS√ç b√Ωt title!**

**Form√°t odpovƒõdi:**
```python
title = "Kr√°tk√Ω popisn√Ω n√°zev"

# ... zbytek k√≥du ...

result = [tv≈Øj_dataframe]
```

**Pravidla pro title:**
- MUS√ç b√Ωt na prvn√≠m ≈ô√°dku ve form√°tu: title = "N√°zev"
- Kr√°tk√Ω (max 60 znak≈Ø), jasn√Ω, bez ot√°zek
- Transformuj dotaz do n√°zvu:
  * "Jak√© byly tr≈æby v lednu 2025?" ‚Üí title = "Tr≈æby leden 2025"
  * "Top 10 z√°kazn√≠k≈Ø" ‚Üí title = "Top 10 z√°kazn√≠k≈Ø"
- Bez zbyteƒçn√Ωch slov ("Jak√©", "Kolik", "Zobraz")
- ƒåesk√Ω jazyk

**Dal≈°√≠ pravidla:**
1. Vygeneruj POUZE Python k√≥d bez dal≈°√≠ho textu (kromƒõ title)
2. K√≥d mus√≠ b√Ωt spustiteln√Ω bez √∫prav
3. Nepou≈æ√≠vej markdown code blocks (```)
4. Posledn√≠ ≈ô√°dek MUS√ç b√Ωt: result = [tv≈Øj_dataframe]
5. V≈ΩDY ≈ôaƒè sestupnƒõ (highest first) pokud u≈æivatel ne≈ôekne jinak
6. Pro mƒõs√≠ƒçn√≠ data V≈ΩDY zahr≈à YoY % a MoM % pokud jsou data k dispozici

**Dostupn√© knihovny:**
- pandas as pd
- numpy as np
- datetime

**Dostupn√© DataFrames v pamƒõti:**
{', '.join([d.replace('.csv', '').replace('.xlsx', '').replace(' ', '_').replace('-', '_') for d in available_datasets])}

**CRITICAL: NIKDY nepou≈æ√≠vej pd.read_csv() nebo pd.read_excel()!**
DataFrames jsou U≈Ω NAƒåTEN√â v pamƒõti. Pou≈æij je p≈ô√≠mo:
```python
# ‚úÖ SPR√ÅVNƒö - DataFrame u≈æ existuje:
sales = Sales.copy()

# ‚ùå ≈†PATNƒö - NIKDY NEPOU≈Ω√çVAT:
sales = pd.read_csv('Sales.csv', ...)  # ‚Üê NIKDY!
```

**üö® CRITICAL WARNING: NEVER SIMULATE OR FABRICATE DATA! üö®**

**ABSOLUTE PROHIBITION - READ CAREFULLY:**
- You MUST ALWAYS use actual data from the loaded DataFrames above
- You MUST NEVER create fake/simulated/example data
- You MUST NEVER use hardcoded lists like `[{{'Mƒõs√≠c': 'Leden', 'Tr≈æby': 123}}]`
- If you don't have data for a query, say so - DON'T MAKE IT UP!

**‚ùå ABSOLUTELY FORBIDDEN - These will cause CRITICAL ERRORS:**
```python
# ‚ùå NEVER DO THIS - Simulated data:
monthly_data = [
    {{'Mƒõs√≠c': 'Leden 2024', 'Tr≈æby': 850000000}},  # ‚Üê FAKE DATA!
    {{'Mƒõs√≠c': '√önor 2024', 'Tr≈æby': 920000000}},
]
df = pd.DataFrame(monthly_data)  # ‚Üê ABSOLUTELY FORBIDDEN!

# ‚ùå NEVER DO THIS - Hardcoded values:
yoy_changes = [-5.2, 3.1, 7.8, 12.5]  # ‚Üê FAKE DATA!
```

**‚úÖ ALWAYS DO THIS - Use actual datasets:**
```python
# ‚úÖ CORRECT - Use loaded DataFrames:
sales = Sales.copy()
date_cols_2024 = [col for col in sales.columns if '2024' in col]
monthly_revenue = sales[date_cols_2024].sum()

# ‚úÖ CORRECT - Calculate from real data:
yoy_2023 = sales[date_cols_2023].sum()
yoy_2024 = sales[date_cols_2024].sum()
yoy_pct = ((yoy_2024 - yoy_2023) / yoy_2023) * 100
```

**THE RULE IS ABSOLUTE:**
Every single number in your output MUST come from the actual DataFrames.
If the data doesn't exist, return an error message - NEVER fabricate it!

Zaƒçni generovat k√≥d NYN√ç (nezapome≈à na title na prvn√≠m ≈ô√°dku!):"""
    
    return prompt


def build_analyst_prompt(
    user_query: str,
    data_result: str,
    format_type: str = "executive"
) -> str:
    """
    Sestav√≠ prompt pro AI Analytika (interpretaci v√Ωsledk≈Ø).
    
    Args:
        user_query: P≈Øvodn√≠ dotaz u≈æivatele
        data_result: Data jako string (df.to_string())
        format_type: Typ form√°tu ("executive", "detailed", "quick")
    
    Returns:
        Prompt pro interpretaci v√Ωsledk≈Ø
    """
    
    structures = {
        "executive": """
üìä EXECUTIVE SUMMARY
[1-2 vƒõty - co data ≈ô√≠kaj√≠ na prvn√≠ pohled, hlavn√≠ z√°vƒõr]

üîç KL√çƒåOV√â POZNATKY
‚Ä¢ [Nejvy≈°≈°√≠/nejni≈æ≈°√≠ hodnoty s konkr√©tn√≠mi ƒç√≠sly]
‚Ä¢ [Trendy a zmƒõny - vƒçetnƒõ MoM, YoY pokud jsou k dispozici]
‚Ä¢ [D≈Øle≈æit√© miln√≠ky nebo zlomov√© body v datech]

‚ö†Ô∏è POZORNOST
[Oblasti vy≈æaduj√≠c√≠ pozornost - poklesy, anom√°lie, potenci√°ln√≠ rizika]

üí° DOPORUƒåEN√ç
[2-3 konkr√©tn√≠ actionable doporuƒçen√≠ pro management]
""",
        "quick": """
Vytvo≈ô struƒçn√Ω koment√°≈ô (5-7 bod≈Ø):
‚Ä¢ [Hlavn√≠ zji≈°tƒõn√≠]
‚Ä¢ [Nejv√Ωznamnƒõj≈°√≠ trend]
‚Ä¢ [Pozornost/varov√°n√≠]
‚Ä¢ [Kl√≠ƒçov√© doporuƒçen√≠]
"""
    }
    
    structure = structures.get(format_type, structures["executive"])
    
    prompt = f"""Jsi senior finanƒçn√≠ analytik a pr√°vƒõ prezentuje≈° v√Ωsledky anal√Ωzy CFO/CEO.

P≈ÆVODN√ç DOTAZ:
{user_query}

DATA K ANAL√ùZE:
{data_result}

{ALZA_CONTEXT}

INSTRUKCE:
{structure}

PRAVIDLA:
- Buƒè konkr√©tn√≠ - V≈ΩDY uv√°dƒõj p≈ôesn√° ƒç√≠sla z dat
- Pou≈æ√≠vej procenta pro srovn√°n√≠ a relativn√≠ zmƒõny
- Pi≈° jasnƒõ, struƒçnƒõ a profesion√°lnƒõ
- Zamƒõ≈ô se na business implikace, ne jen such√° ƒç√≠sla
- Pokud vid√≠≈° sez√≥nn√≠ trendy, zmi≈à je a vysvƒõtli
- Buƒè proaktivn√≠ v doporuƒçen√≠ch - navrhuj konkr√©tn√≠ akce
- Nepou≈æ√≠vej √∫vodn√≠ fr√°ze typu "R√°d v√°m p≈ôedstav√≠m" - jdi rovnou k vƒõci
- Form√°tuj ƒç√≠sla s mezerami jako tis√≠cov√© oddƒõlovaƒçe (nap≈ô. 1 234 567)
- Pou≈æ√≠vej ƒçesk√© mƒõny a form√°ty (Kƒç)

Zaƒçni hned s anal√Ωzou."""
    
    return prompt


# ==============================================================================
# HELPER FUNCTIONS
# ==============================================================================

def get_available_datasets_from_db(user_id: str) -> List[str]:
    """
    Naƒçte seznam dostupn√Ωch dataset≈Ø pro u≈æivatele z datab√°ze.
    TODO: Implementovat datab√°zov√Ω dotaz
    """
    # Placeholder - bude nahrazeno DB query
    return ["Sales.csv", "Documents.csv", "M3.csv", "Bridge_Shipping_Types.csv"]
